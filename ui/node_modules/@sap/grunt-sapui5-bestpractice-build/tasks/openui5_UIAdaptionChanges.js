var fs = require('fs');
var path = require('path');

function bundleChanges(grunt) {
    function readJSON(jsonPath, del) {
        return new Promise((resolve, reject) => {
            fs.readFile(jsonPath, 'utf8', function (err, data) {
                if (err) {
                    reject(err);
                }
                if (del) fs.unlinkSync(jsonPath);
                var parsed = JSON.parse(data);
                resolve(parsed);
            });
        });
    }

    function writeJSON(jsonPath, data) {
        return new Promise((resolve, reject) => {
            var dir = path.dirname(jsonPath);
            var pathsToCreate = [];
            while (!fs.existsSync(dir)) {
                pathsToCreate.push(dir);
                dir = path.dirname(dir);
            }
            pathsToCreate.reverse().forEach(function (dir) {
                fs.mkdirSync(dir);
            });
            data.sort(function (cA, cB) {
                return new Date(cA.creation || 0) - new Date(cB.creation || 0);
            });
            fs.writeFile(jsonPath, JSON.stringify(data), function (err, data) {
                if (err) {
                    reject(err);
                }
                resolve();
            });
        });
    }

    function listFilesInFolder(folderPath, doRecursive) {
        var files = [];
        var folderStat = fs.statSync(folderPath);
        if (!folderStat.isDirectory()) {
            return files;
        }
        var items = fs.readdirSync(folderPath);
        items.forEach(function(item) {
            var itemPath = path.resolve(folderPath, item);
            var stat = fs.statSync(itemPath);

            if (stat.isDirectory() && doRecursive) {
                files = files.concat(listFilesInFolder(itemPath, doRecursive));
            } else if (stat.isFile()) {
                files.push(itemPath);
            }
        });
        return files;
    }

    return new Promise((resolve, reject) => {
        var appFolder = grunt.config.get('dir.appFolder');
        var tmpDir = grunt.config.get('dir.tmpDir');
        if (!appFolder || !tmpDir) {
            resolve();
        }
        var changesSourceFolder = path.join(appFolder, 'changes');
        var changesTargetFolder = path.join(tmpDir, 'changes');

        if (fs.existsSync(changesSourceFolder)) {
            var changesBundle = path.join(changesTargetFolder, 'changes-bundle.json');
            var filePaths = [];
            try {
                filePaths = listFilesInFolder(changesSourceFolder, true);
            } catch (err) {
                reject(err);
            }
            var actions = filePaths.map(item => {
                return readJSON(item, false);
            });
            return Promise.all(actions).then(results => {
                return writeJSON(changesBundle, results).then(() => {
                    resolve();
                });
            }).catch((err) => {
                grunt.log.warn("failed to read changes file");
                reject(err);
            });
        } else {
            resolve();
        }
    });
}

function cleanupChanges(grunt) {
    return new Promise((resolve, reject) => {
        var distFolder = grunt.config.get('dir.dist');
        if (!distFolder) {
            resolve();
        }
        var changesTargetFolder = path.join(distFolder, 'changes');
        if (fs.existsSync(changesTargetFolder)) {
            return fs.readdir(changesTargetFolder, function (err, items) {
                if (err) {
                    reject(err);
                }
                var deletedItemCount = 0;
                if (items) {
                    items.map(item => {
                        if (path.extname(item) == '.change') {
                            fs.unlinkSync(path.join(changesTargetFolder, item));
                            deletedItemCount++;
                        }
                    });
                }
                resolve();
            });
        } else {
            resolve();
        }
//        grunt.log.writeln('Deleted ' + (deletedItemCount + '')['cyan'] + ' changes');
    });
}

module.exports = function(grunt) {
    grunt.registerTask("bundleChanges", 'Task to bundle level-0-changes.', function () {
        var done = this.async();
        bundleChanges(grunt).then(() => {
            done();
        }).catch((err) => {
            grunt.log.warn("failed to bundle level-0-changes");
            done();
        });
    });

    grunt.registerTask("cleanupChanges", 'Task to delete level-0-changes in dist folder.', function () {
        var done = this.async();
        cleanupChanges(grunt).then(() => {
            done();
        }).catch((err) => {
            grunt.log.warn("failed to delete level-0-changes in dist folder");
            done();
        });
    });

}
